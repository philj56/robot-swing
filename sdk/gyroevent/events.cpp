/**
 *
 * Version : $Id$
 * This file was generated by Aldebaran Robotics ModuleGenerator
 */

#include "events.h"

#include <alvalue/alvalue.h>
#include <alcommon/alproxy.h>
#include <alcommon/albroker.h>

#include <vector>

#include <qi/os.hpp>
#include <qi/log.hpp>


GyroEvents::GyroEvents(
  boost::shared_ptr<AL::ALBroker> broker,
  const std::string& name):
      AL::ALModule(broker, name),
      fMemoryProxy(getParentBroker())
{
  setModuleDescription("");
  datapoints = 20.0;

  functionName("callback", getName(), "");
  BIND_METHOD(GyroEvents::callback)

  lastvalues.resize(20);
}

GyroEvents::~GyroEvents() {
  fMemoryProxy.unsubscribeToEvent("Gyroevent", "Events");
  fMemoryProxy.unsubscribeToMicroEvent("ExampleMicroEvent", "Events");
}

void GyroEvents::init() {
  try {
    //Allow ALMemory to start the Events module when someone subscribe to Gyroevent
    //This module should inherit from ALExtractor
    //It's not necessary to call this function when you dont want the autostart feature
    fMemoryProxy.declareEvent("Gyroevent", "GyroEvents");
    fMemoryProxy.declareEvent("Gyroaverageturn", "GyroEvents");

    gettimeofday(&startTime);
    gettimeofday(&currentTime);
    
    timer();


    fMemoryProxy.subscribeToEvent("Gyroevent", "GyroEvents", "callback");
        fMemoryProxy.subscribeToEvent("Gyroevent", "GyroEvents", "AverageTurn");
    fMemoryProxy.subscribeToMicroEvent("ExampleMicroEvent", "GyroEvents", "AnotherUserDataToIdentifyEvent", "callback");

    fGyroY = (AL::ALValue*)(fMemoryProxy.getDataPtr("Device/SubDeviceList/InertialSensor/GyroscopeY/Sensor/Value"));
    
    for (int i = 0; i < datapoints; i++){
        fgyro = *fGyroY;
        ftotal += fgyro;
        lastvalues[i] = fgyro;
    }
    
    Average();
    
    while (true){
        //This needs to sleep during a movement
        //After movement is complete, reset average 
        
        timer();
        fgyro = *fGyroY;
        ftotal -= lastvalues[0];
        lastvalues.erase(lastvalues.begin());
        ftotal += fgyro;
        Average();
        generateEvent(faverage);
    }

    //generate a simple event for the test
    //generateEvent(42.0);
    //generateMicroEvent(42.0);
  }
  catch (const AL::ALError& e) {
    qiLogError("module.example") << e.what() << std::endl;
  }

}

void GyroEvents::timer(){
    
    time = 1000 * (static_cast<int>(currentTime.tv_sec) - static_cast<int>(startTime.tv_sec)) 
			       + 0.001 * static_cast<float>(static_cast<int>(currentTime.tv_usec) - static_cast<int>(startTime.tv_usec));
		
}

void GyroEvents::Average(){
    foldaverage = faverage; 
    faverage = ftotal/datapoints;
    
    if (abs(foldaverage) < abs(faverage)){
        fMemoryProxy.raiseEvent("Gyroaverageturn", foldaverage);
    }
}

void GyroEvents::generateEvent(const float& value) {
  /** Raise an event with its value (here a float, but could be something else.*/
  fMemoryProxy.raiseEvent("Gyroevent", value);
}

void GyroEvents::generateMicroEvent(const float& value) {
  /** Raise an event with its value (here a float, but could be something else.*/
  fMemoryProxy.raiseMicroEvent("ExampleMicroEvent", value);
}

void GyroEvents::callback(const std::string &key, const AL::ALValue &value, const AL::ALValue &msg) {
  qiLogInfo("module.example") << "Callback:" << key << std::endl;
  qiLogInfo("module.example") << "Value   :" << value << std::endl;
  qiLogInfo("module.example") << "Msg     :" << msg << std::endl;
}
